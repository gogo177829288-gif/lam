<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LAMPPOLI ‚Äî Enter the Unknown</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@300;400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #ffffff;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      color: #1a1a1a;
    }
    
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    /* Sakura Petals */
    .sakura-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 15;
      overflow: hidden;
    }
    
    .sakura {
      position: absolute;
      top: -50px;
      animation: fall linear infinite;
    }
    
    .sakura::before {
      content: '';
      display: block;
      width: var(--size);
      height: var(--size);
      background: linear-gradient(135deg, #ffb7c5 0%, #ff69b4 50%, #ffb7c5 100%);
      border-radius: 50% 0 50% 50%;
      transform: rotate(45deg);
      opacity: 0.8;
      box-shadow: 0 0 10px rgba(255, 183, 197, 0.5);
    }
    
    @keyframes fall {
      0% {
        transform: translateY(-10vh) rotate(0deg) translateX(0);
        opacity: 1;
      }
      25% {
        transform: translateY(25vh) rotate(90deg) translateX(20px);
      }
      50% {
        transform: translateY(50vh) rotate(180deg) translateX(-20px);
      }
      75% {
        transform: translateY(75vh) rotate(270deg) translateX(20px);
      }
      100% {
        transform: translateY(110vh) rotate(360deg) translateX(-10px);
        opacity: 0.3;
      }
    }
    
    /* Soft gradient overlay */
    .gradient-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse at 50% 100%, rgba(255, 183, 197, 0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 0% 0%, rgba(255, 218, 233, 0.15) 0%, transparent 40%),
        radial-gradient(ellipse at 100% 0%, rgba(255, 218, 233, 0.15) 0%, transparent 40%);
      pointer-events: none;
      z-index: 2;
    }
    
    /* Title - positioned at bottom */
    .title {
      position: fixed;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 20;
      pointer-events: none;
    }
    
    .title h1 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: clamp(2.5rem, 10vw, 7rem);
      letter-spacing: 0.15em;
      color: #2a2a2a;
      text-shadow: 
        0 0 40px rgba(255, 150, 180, 0.3),
        0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .title .subtitle {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: clamp(0.5rem, 1.5vw, 0.8rem);
      letter-spacing: 0.4em;
      color: rgba(100, 100, 100, 0.7);
      margin-top: 0.5rem;
      font-weight: 300;
    }
    
    .title .jp-text {
      font-family: 'Noto Sans JP', sans-serif;
      font-size: clamp(0.7rem, 1.5vw, 1rem);
      color: #ffb7c5;
      margin-bottom: 0.3rem;
      letter-spacing: 0.3em;
    }
    
    /* Corner UI */
    .corner-ui {
      position: fixed;
      z-index: 30;
      font-size: 0.5rem;
      color: rgba(150, 150, 150, 0.6);
      letter-spacing: 0.15em;
      pointer-events: none;
    }
    
    .corner-ui.top-left { top: 2rem; left: 2rem; }
    .corner-ui.top-right { top: 2rem; right: 2rem; text-align: right; }
    .corner-ui.bottom-left { bottom: 2rem; left: 2rem; }
    .corner-ui.bottom-right { bottom: 2rem; right: 2rem; text-align: right; }
    
    .corner-ui .value {
      color: #ffb7c5;
      display: block;
      margin-top: 0.3rem;
    }
    
    /* CTA */
    .cta {
      position: fixed;
      bottom: 5%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 30;
      padding: 0.8rem 2.5rem;
      background: rgba(255, 183, 197, 0.15);
      border: 1px solid rgba(255, 150, 180, 0.4);
      color: #555;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.6rem;
      letter-spacing: 0.3em;
      cursor: pointer;
      transition: all 0.4s;
      backdrop-filter: blur(10px);
      border-radius: 2px;
    }
    
    .cta:hover {
      background: rgba(255, 183, 197, 0.3);
      border-color: #ffb7c5;
      color: #333;
      box-shadow: 0 0 30px rgba(255, 150, 180, 0.3);
      transform: translateX(-50%) scale(1.05);
    }
    
    /* Loading */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s, visibility 1s;
    }
    
    .loading.hidden {
      opacity: 0;
      visibility: hidden;
    }
    
    .loading-text {
      font-size: 0.9rem;
      letter-spacing: 0.5em;
      color: #ffb7c5;
      animation: loadingPulse 1.5s ease-in-out infinite;
    }
    
    .loading-sakura {
      font-size: 2rem;
      margin-bottom: 1rem;
      animation: loadingSpin 2s linear infinite;
    }
    
    @keyframes loadingPulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    @keyframes loadingSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Instructions */
    .instructions {
      position: fixed;
      top: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 25;
      font-size: 0.5rem;
      color: rgba(150, 150, 150, 0.4);
      letter-spacing: 0.2em;
      pointer-events: none;
    }
  </style>
</head>
<body>
  
  <!-- Loading Screen -->
  <div class="loading" id="loading">
    <div class="loading-sakura">üå∏</div>
    <div class="loading-text">LOADING...</div>
  </div>
  
  <!-- 3D Canvas -->
  <div id="canvas-container"></div>
  
  <!-- Gradient Overlay -->
  <div class="gradient-overlay"></div>
  
  <!-- Sakura Petals -->
  <div class="sakura-container" id="sakura-container"></div>
  
  <!-- Instructions -->
  <div class="instructions">DRAG TO ROTATE ‚Ä¢ SCROLL TO ZOOM</div>
  
  <!-- Title at bottom -->
  <div class="title">
    <p class="jp-text">Ê°ú„ÅÆÁâ©Ë™û</p>
    <h1>LAMPPOLI</h1>
    <p class="subtitle">Enter the Unknown</p>
  </div>
  
  <!-- Corner UI -->
  <div class="corner-ui top-left">
    STATUS<br>
    <span class="value">‚óè ONLINE</span>
  </div>
  <div class="corner-ui top-right">
    SEASON<br>
    <span class="value">01</span>
  </div>
  <div class="corner-ui bottom-left">
    VER 1.0.0
  </div>
  <div class="corner-ui bottom-right">
    2026
  </div>
  
  <!-- CTA -->
  <button class="cta" onclick="alert('Stories coming soon!')">BEGIN JOURNEY</button>

  <!-- Three.js and VRM -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/",
      "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.min.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
    
    // Mixamo to VRM bone mapping
    const mixamoVRMRigMap = {
      mixamorigHips: 'hips',
      mixamorigSpine: 'spine',
      mixamorigSpine1: 'chest',
      mixamorigSpine2: 'upperChest',
      mixamorigNeck: 'neck',
      mixamorigHead: 'head',
      mixamorigLeftShoulder: 'leftShoulder',
      mixamorigLeftArm: 'leftUpperArm',
      mixamorigLeftForeArm: 'leftLowerArm',
      mixamorigLeftHand: 'leftHand',
      mixamorigLeftHandThumb1: 'leftThumbMetacarpal',
      mixamorigLeftHandThumb2: 'leftThumbProximal',
      mixamorigLeftHandThumb3: 'leftThumbDistal',
      mixamorigLeftHandIndex1: 'leftIndexProximal',
      mixamorigLeftHandIndex2: 'leftIndexIntermediate',
      mixamorigLeftHandIndex3: 'leftIndexDistal',
      mixamorigLeftHandMiddle1: 'leftMiddleProximal',
      mixamorigLeftHandMiddle2: 'leftMiddleIntermediate',
      mixamorigLeftHandMiddle3: 'leftMiddleDistal',
      mixamorigLeftHandRing1: 'leftRingProximal',
      mixamorigLeftHandRing2: 'leftRingIntermediate',
      mixamorigLeftHandRing3: 'leftRingDistal',
      mixamorigLeftHandPinky1: 'leftLittleProximal',
      mixamorigLeftHandPinky2: 'leftLittleIntermediate',
      mixamorigLeftHandPinky3: 'leftLittleDistal',
      mixamorigRightShoulder: 'rightShoulder',
      mixamorigRightArm: 'rightUpperArm',
      mixamorigRightForeArm: 'rightLowerArm',
      mixamorigRightHand: 'rightHand',
      mixamorigRightHandThumb1: 'rightThumbMetacarpal',
      mixamorigRightHandThumb2: 'rightThumbProximal',
      mixamorigRightHandThumb3: 'rightThumbDistal',
      mixamorigRightHandIndex1: 'rightIndexProximal',
      mixamorigRightHandIndex2: 'rightIndexIntermediate',
      mixamorigRightHandIndex3: 'rightIndexDistal',
      mixamorigRightHandMiddle1: 'rightMiddleProximal',
      mixamorigRightHandMiddle2: 'rightMiddleIntermediate',
      mixamorigRightHandMiddle3: 'rightMiddleDistal',
      mixamorigRightHandRing1: 'rightRingProximal',
      mixamorigRightHandRing2: 'rightRingIntermediate',
      mixamorigRightHandRing3: 'rightRingDistal',
      mixamorigRightHandPinky1: 'rightLittleProximal',
      mixamorigRightHandPinky2: 'rightLittleIntermediate',
      mixamorigRightHandPinky3: 'rightLittleDistal',
      mixamorigLeftUpLeg: 'leftUpperLeg',
      mixamorigLeftLeg: 'leftLowerLeg',
      mixamorigLeftFoot: 'leftFoot',
      mixamorigLeftToeBase: 'leftToes',
      mixamorigRightUpLeg: 'rightUpperLeg',
      mixamorigRightLeg: 'rightLowerLeg',
      mixamorigRightFoot: 'rightFoot',
      mixamorigRightToeBase: 'rightToes',
    };
    
    // Function to load and retarget Mixamo animation to VRM
    function loadMixamoAnimation(url, vrm) {
      const fbxLoader = new FBXLoader();
      
      return new Promise((resolve, reject) => {
        fbxLoader.load(url, (fbx) => {
          const clip = fbx.animations[0];
          
          if (!clip) {
            reject(new Error('No animation found in FBX'));
            return;
          }
          
          const tracks = [];
          const restRotationInverse = new THREE.Quaternion();
          const parentRestWorldRotation = new THREE.Quaternion();
          const _quatA = new THREE.Quaternion();
          const _vec3 = new THREE.Vector3();
          
          const motionHipsHeight = fbx.getObjectByName('mixamorigHips')?.position.y || 1;
          const vrmHipsY = vrm.humanoid?.getNormalizedBoneNode('hips')?.getWorldPosition(_vec3).y || 1;
          const vrmRootY = vrm.scene.getWorldPosition(_vec3).y;
          const vrmHipsHeight = Math.abs(vrmHipsY - vrmRootY);
          const hipsPositionScale = vrmHipsHeight / motionHipsHeight;
          
          clip.tracks.forEach((track) => {
            const trackSplitted = track.name.split('.');
            const mixamoRigName = trackSplitted[0];
            const vrmBoneName = mixamoVRMRigMap[mixamoRigName];
            const vrmBoneNode = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName);
            const mixamoRigNode = fbx.getObjectByName(mixamoRigName);
            
            if (vrmBoneNode && mixamoRigNode) {
              const propertyName = trackSplitted[1];
              
              mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
              mixamoRigNode.parent?.getWorldQuaternion(parentRestWorldRotation) || parentRestWorldRotation.identity();
              
              if (track instanceof THREE.QuaternionKeyframeTrack) {
                for (let i = 0; i < track.values.length; i += 4) {
                  const flatQuaternion = track.values.slice(i, i + 4);
                  _quatA.fromArray(flatQuaternion);
                  _quatA.premultiply(parentRestWorldRotation).multiply(restRotationInverse);
                  _quatA.toArray(flatQuaternion);
                  flatQuaternion.forEach((v, j) => { track.values[i + j] = v; });
                }
                
                tracks.push(new THREE.QuaternionKeyframeTrack(
                  `${vrmBoneNode.name}.${propertyName}`,
                  track.times,
                  track.values.map((v, i) => (i % 2 === 0 ? -v : v))
                ));
              } else if (track instanceof THREE.VectorKeyframeTrack) {
                const value = track.values.map((v, i) => 
                  (i % 3 !== 1 ? -v : v) * hipsPositionScale
                );
                tracks.push(new THREE.VectorKeyframeTrack(
                  `${vrmBoneNode.name}.${propertyName}`,
                  track.times,
                  value
                ));
              }
            }
          });
          
          resolve(new THREE.AnimationClip(url, clip.duration, tracks));
        }, undefined, reject);
      });
    }
    
    // Create Sakura Petals
    const sakuraContainer = document.getElementById('sakura-container');
    for (let i = 0; i < 50; i++) {
      const petal = document.createElement('div');
      petal.className = 'sakura';
      petal.style.cssText = `
        --size: ${Math.random() * 12 + 8}px;
        left: ${Math.random() * 100}%;
        animation-duration: ${Math.random() * 8 + 8}s;
        animation-delay: ${Math.random() * 10}s;
      `;
      sakuraContainer.appendChild(petal);
    }
    
    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    
    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 5);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 2;
    controls.maxDistance = 8;
    controls.target.set(0, 1, 0);
    controls.update();
    
    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainLight.position.set(1, 1, 1);
    scene.add(mainLight);
    const fillLight = new THREE.DirectionalLight(0xffeeff, 0.5);
    fillLight.position.set(-1, 1, -1);
    scene.add(fillLight);
    
    // Animation state machine
    let currentVrm = null;
    let mixer = null;
    let animations = {};
    let currentAction = null;
    let state = 'laying';
    let stateStart = 0;
    
    const TIMING = {
      laying: 2,           // –õ–µ–∂–∏—Ç 2 —Å–µ–∫
      standingUp: 3.5,     // –í—Å—Ç–∞—ë—Ç ~3.5 —Å–µ–∫
      idlePause: 4,        // –°—Ç–æ–∏—Ç –ø–æ—Å–ª–µ –≤—Å—Ç–∞–≤–∞–Ω–∏—è 4 —Å–µ–∫
      walkRight: 2.5,      // –ò–¥—ë—Ç –≤–ø—Ä–∞–≤–æ 2.5 —Å–µ–∫
      walkBack: 2.5,       // –ò–¥—ë—Ç –Ω–∞–∑–∞–¥ 2.5 —Å–µ–∫
      dancing: 20,         // –¢–∞–Ω—Ü—É–µ—Ç 20 —Å–µ–∫
      idleAfterDance: 7,   // –°—Ç–æ–∏—Ç 7 —Å–µ–∫ –ø–æ—Å–ª–µ —Ç–∞–Ω—Ü–∞
      yawn: 8,             // –ó–µ–≤–∞–µ—Ç ~8 —Å–µ–∫
      idleFinal: Infinity  // –ü–æ—Ç–æ–º —Å—Ç–æ–∏—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ
    };
    
    // Blinking
    let blinkTimer = 0;
    let isBlinking = false;
    let nextBlink = 3;
    
    function playAnim(name, loop = true, fade = 0.4) {
      if (!mixer || !animations[name]) return;
      const newAction = mixer.clipAction(animations[name]);
      newAction.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
      newAction.clampWhenFinished = !loop;
      if (currentAction) currentAction.fadeOut(fade);
      newAction.reset().fadeIn(fade).play();
      currentAction = newAction;
    }
    
    function setState(newState) {
      state = newState;
      stateStart = clock.elapsedTime;
      
      if (newState === 'laying') playAnim('laying', true, 0.2);
      else if (newState === 'standingUp') playAnim('standingUp', false, 0.3);
      else if (newState === 'idlePause') playAnim('idle', true, 0.4);
      else if (newState === 'walkRight' || newState === 'walkBack') playAnim('walking', true, 0.3);
      else if (newState === 'dancing') playAnim('dancing', true, 0.5);
      else if (newState === 'idleAfterDance') playAnim('idle', true, 0.5);
      else if (newState === 'yawn') playAnim('yawn', false, 0.4);
      else if (newState === 'idleFinal') playAnim('idle', true, 0.5);
    }
    
    // Load VRM
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));
    
    loader.load('elysia.vrm', async (gltf) => {
      const vrm = gltf.userData.vrm;
      if (!vrm) return;
      
      currentVrm = vrm;
      VRMUtils.removeUnnecessaryJoints(vrm.scene);
      VRMUtils.removeUnnecessaryVertices(vrm.scene);
      vrm.scene.rotation.y = Math.PI;
      scene.add(vrm.scene);
      
      mixer = new THREE.AnimationMixer(vrm.scene);
      
      // Load animations
      const files = {
        laying: 'Female Laying Pose.fbx',
        standingUp: 'Standing Up.fbx',
        walking: 'Walking.fbx',
        idle: 'Idle.fbx',
        dancing: 'Dancing.fbx',
        yawn: 'Yawn.fbx'
      };
      
      for (const [name, file] of Object.entries(files)) {
        try {
          animations[name] = await loadMixamoAnimation(file, vrm);
          console.log('Loaded:', name);
        } catch (e) {
          console.error('Failed:', name, e);
        }
      }
      
      setState('laying');
      document.getElementById('loading').classList.add('hidden');
    },
    (p) => {
      if (p.total) document.querySelector('.loading-text').textContent = `LOADING... ${(p.loaded/p.total*100).toFixed(0)}%`;
    },
    (e) => console.error(e));
    
    // Animation loop
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.elapsedTime;
      const stateTime = elapsed - stateStart;
      
      if (mixer) mixer.update(delta);
      
      if (currentVrm) {
        currentVrm.update(delta);
        
        // State transitions
        if (state === 'laying' && stateTime >= TIMING.laying) setState('standingUp');
        else if (state === 'standingUp' && stateTime >= TIMING.standingUp) setState('idlePause');
        else if (state === 'idlePause' && stateTime >= TIMING.idlePause) setState('walkRight');
        else if (state === 'walkRight') {
          if (currentVrm.scene.position.x < 1.5) {
            currentVrm.scene.position.x += delta * 0.6;
            currentVrm.scene.rotation.y = Math.PI * 0.7;
          }
          if (stateTime >= TIMING.walkRight) setState('walkBack');
        }
        else if (state === 'walkBack') {
          if (currentVrm.scene.position.x > 0) {
            currentVrm.scene.position.x -= delta * 0.6;
            currentVrm.scene.rotation.y = Math.PI * 1.3;
          }
          if (stateTime >= TIMING.walkBack) {
            currentVrm.scene.position.x = 0;
            currentVrm.scene.rotation.y = Math.PI;
            setState('dancing');
          }
        }
        else if (state === 'dancing') {
          currentVrm.scene.rotation.y = Math.PI + Math.sin(elapsed * 0.5) * 0.1;
          if (stateTime >= TIMING.dancing) {
            currentVrm.scene.rotation.y = Math.PI;
            setState('idleAfterDance');
          }
        }
        else if (state === 'idleAfterDance') {
          currentVrm.scene.rotation.y = Math.PI + Math.sin(elapsed * 0.3) * 0.05;
          if (stateTime >= TIMING.idleAfterDance) setState('yawn');
        }
        else if (state === 'yawn') {
          if (stateTime >= TIMING.yawn) setState('idleFinal');
        }
        else if (state === 'idleFinal') {
          currentVrm.scene.rotation.y = Math.PI + Math.sin(elapsed * 0.3) * 0.05;
        }
        
        // Blinking
        blinkTimer += delta;
        if (!isBlinking && blinkTimer > nextBlink) {
          isBlinking = true;
          blinkTimer = 0;
        }
        if (isBlinking && currentVrm.expressionManager) {
          const p = blinkTimer / 0.15;
          if (p < 1) currentVrm.expressionManager.setValue('blink', Math.sin(p * Math.PI));
          else {
            currentVrm.expressionManager.setValue('blink', 0);
            isBlinking = false;
            blinkTimer = 0;
            nextBlink = 2 + Math.random() * 4;
          }
        }
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
